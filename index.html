<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[INIT] OMEGA CONFERENCE v1.0.3</title>
    <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script> 
    <style>
        /* [HACKER_STYLE] */
        body {
            background-color: #000000;
            color: #00FF00;
            font-family: 'Consolas', 'Monospace', monospace;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .main-grid {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            border: 2px solid #00FF00;
            box-shadow: 0 0 15px #00FF00;
            padding: 10px;
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 10px;
        }
        
        .video-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 250px;
            border: 1px solid #FF00FF;
            padding: 5px;
        }
        
        .video-wrapper {
            position: relative;
            width: 48%; /* 2 колонки */
            min-width: 200px;
            background-color: #111;
            border: 2px solid #FF00FF;
            box-sizing: border-box;
        }
        
        .video-wrapper video {
            width: 100%;
            height: auto;
            display: block;
        }
        
        .video-label {
            position: absolute;
            bottom: 0;
            left: 0;
            background-color: rgba(0, 0, 0, 0.7);
            color: #00FF00;
            padding: 2px 5px;
            font-size: 0.8em;
            width: 100%;
            box-sizing: border-box;
            text-align: center;
        }
        
        .chat-box {
            height: 40vh; 
            overflow-y: scroll;
            margin-bottom: 10px;
            padding: 5px;
            border: 1px solid #006600;
        }
        /* Остальные стили из предыдущей версии (кнопки, инпуты) */
        .system-message { color: #FFFF00; font-weight: bold; }
        .user-message strong { color: #00AAFF; margin-right: 5px; }
        
        input[type="text"], button {
            background-color: #111111;
            color: #00FF00;
            border: 1px solid #00FF00;
            padding: 8px;
            font-family: inherit;
        }
        
        .message-input { display: flex; }
        .message-input input { flex-grow: 1; margin-right: 5px; }
        
        #nickname_display, #peer_id_display { margin-bottom: 10px; color: #FF00FF; }
    </style>
</head>
<body>

    <div class="main-grid">
        
        <div class="left-panel">
            <p id="nickname_display">STATUS: [PENDING CALLSIGN]</p>
            <p id="peer_id_display">PEER_ID: [GENERATING...]</p>

            <div class="form-group" id="nick_form">
                <input type="text" id="nickname_input" placeholder=">>> ENTER YOUR CALLSIGN" required>
                <button onclick="saveNickname()">[INIT_CONFERENCE]</button>
            </div>
            
            <div class="video-grid" id="video_grid">
                </div>

            <div class="call-controls">
                <h3>[CONFERENCE_CONTROLS]</h3>
                <button id="hangupButton" disabled onclick="hangUp()">[TERMINATE_ALL]</button>
                <button id="audioToggle" disabled onclick="toggleAudio()">[MUTE_AUDIO]</button>
                <button id="videoToggle" disabled onclick="toggleVideo()">[DISABLE_VIDEO]</button>
            </div>
        </div>

        <div class="right-panel">
            <h3>[GLOBAL_CHAT_LOG]</h3>
            <div class="chat-box" id="chat_box">
                </div>

            <div class="message-input">
                <input type="text" id="message_input" placeholder=">>> MESSAGE (ENTER to transmit)" onkeydown="if(event.keyCode===13) sendMessage()" disabled>
                <button onclick="sendMessage()" id="send_button" disabled>[TRANSMIT]</button>
            </div>
        </div>
    </div>

    <script>
        // ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ
        let ws;
        let peerId; 
        let nickname;
        let localStream;
        // КАРТА ДЛЯ ХРАНЕНИЯ СОЕДИНЕНИЙ: { peerId: simple-peer_instance }
        const peers = new Map();
        // КАРТА ДЛЯ ХРАНЕНИЯ ИНФОРМАЦИИ О ПОЛЬЗОВАТЕЛЯХ: { peerId: { id, nickname } }
        let allUsers = new Map();

        // ЭЛЕМЕНТЫ DOM
        const chatBox = document.getElementById('chat_box');
        const messageInput = document.getElementById('message_input');
        const sendButton = document.getElementById('send_button');
        const nicknameInput = document.getElementById('nickname_input');
        const setNickButton = document.getElementById('nick_form').querySelector('button');
        const nicknameDisplay = document.getElementById('nickname_display');
        const peerIdDisplay = document.getElementById('peer_id_display');
        const videoGrid = document.getElementById('video_grid');
        const hangupButton = document.getElementById('hangupButton');
        const audioToggle = document.getElementById('audioToggle');
        const videoToggle = document.getElementById('videoToggle');

        // [INIT] ГЕНЕРАЦИЯ УНИКАЛЬНОГО ID И WEB SOCKET
        peerId = 'PEER_' + Math.random().toString(36).substring(2, 9).toUpperCase();
        peerIdDisplay.textContent = `PEER_ID: [${peerId}]`;
        
        function initWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}`);

            ws.onopen = function() {
                // Если ник уже есть, сразу регистрируем Peer ID и запускаем медиа
                const savedNick = localStorage.getItem('nickname');
                if (savedNick) {
                    nicknameInput.value = savedNick;
                    saveNickname(true); // Автозапуск
                } else {
                    displayMessage({ type: 'SYSTEM', message: 'ENTER_CALLSIGN_TO_INITIATE_CONFERENCE.' });
                }
            };

            ws.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleIncomingMessage(data);
                } catch (e) {
                    displayMessage({ type: 'ERROR', message: 'INCOMING DATA CORRUPTED.' });
                }
            };
            
            ws.onclose = function() {
                displayMessage({ type: 'SYSTEM', message: 'CONNECTION_LOST. RESTARTING PROTOCOLS...' });
                messageInput.disabled = true;
                sendButton.disabled = true;
                hangUp(false); // Не пытаемся переподключиться
            };
        }

        // [NICKNAME_HANDLER] Сохранение ника, запуск медиа и регистрация
        async function saveNickname(auto = false) {
            const nick = nicknameInput.value.trim().toUpperCase();

            if (nick.length < 2) {
                if (!auto) alert("NICKNAME_ERROR: TOO SHORT (MIN 2 CHARACTERS)");
                return;
            }

            nickname = nick;
            localStorage.setItem('nickname', nickname);
            nicknameDisplay.innerHTML = `STATUS: [CALLSIGN SET AS: ${nickname}]`;
            
            // 1. Активация контролов
            messageInput.disabled = false;
            sendButton.disabled = false;
            nicknameInput.disabled = true;
            setNickButton.disabled = true;
            messageInput.focus();
            
            // 2. Получение локального потока и добавление его в DOM
            try {
                await initLocalMedia();
            } catch (e) {
                displayMessage({ type: 'ERROR', message: `MEDIA_INIT_FAIL: ${e.message}. VOICE/VIDEO DISABLED.` });
            }
            
            // 3. Регистрация в глобальном чате
            if (ws.readyState === WebSocket.OPEN) {
                 ws.send(JSON.stringify({
                    type: 'REGISTER',
                    peerId: peerId,
                    sender: nickname
                }));
            }
        }
        
        // [MEDIA] Инициализация локального потока
        async function initLocalMedia() {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            
            // Создание элемента для локального видео
            const localWrapper = createVideoWrapper(peerId, nickname + ' (LOCAL)');
            const localVideo = localWrapper.querySelector('video');
            localVideo.muted = true; // Отключаем звук для своего видео
            localVideo.srcObject = localStream;
            videoGrid.appendChild(localWrapper);
            
            // Активация контролов
            hangupButton.disabled = false;
            audioToggle.disabled = false;
            videoToggle.disabled = false;
        }

        // [WS_RECEIVE] Обработка входящих WS-сообщений
        function handleIncomingMessage(data) {
            switch (data.type) {
                case 'SYSTEM':
                case 'CHAT_MESSAGE':
                    displayMessage(data);
                    break;
                case 'USER_LIST_UPDATE':
                    updateUserList(data.users);
                    break;
                case 'USER_LEFT':
                    removePeer(data.leftId);
                    displayMessage({ type: 'SYSTEM', message: `USER_LEFT: ${data.leftId}` });
                    break;
                case 'WEBRTC_SIGNAL':
                    // Сигнал предназначен для peerId, который его должен обработать (либо инициатор, либо ответчик)
                    handleSignal(data.senderId, data.signal);
                    break;
            }
        }

        // [USER_LIST] Обновление списка активных пользователей и синхронизация P2P
        function updateUserList(users) {
            const newUsersMap = new Map();
            users.forEach(u => newUsersMap.set(u.id, u));
            
            // 1. Обработка пользователей, которые ушли
            for (const id of allUsers.keys()) {
                if (!newUsersMap.has(id) && id !== peerId) {
                    removePeer(id);
                }
            }
            
            // 2. Обработка новых пользователей
            for (const [id, user] of newUsersMap.entries()) {
                // Если это не мы сами, и это новый пользователь, и у нас нет соединения с ним
                if (id !== peerId && !peers.has(id)) {
                    // Создаем новое P2P соединение (мы будем инициатором, если наш ID < их ID)
                    const initiator = peerId < id; 
                    if (localStream) {
                        createPeer(id, user.nickname, initiator);
                    } else {
                        // Если медиа не запущено, мы не можем начать соединение (только слушать)
                        displayMessage({ type: 'WARNING', message: `Cannot initiate P2P with ${id}. Local media not running.` });
                    }
                }
            }
            
            allUsers = newUsersMap;
        }

        // [PEER_MANAGER] Создание нового P2P соединения
        function createPeer(targetId, targetNickname, initiator) {
            // Если соединение уже есть, игнорируем
            if (peers.has(targetId)) return;

            displayMessage({ 
                type: 'SYSTEM', 
                message: `P2P_INIT: ${targetNickname} (${targetId}). Initiator: ${initiator}` 
            });

            // Создание SimplePeer
            const newPeer = new SimplePeer({
                initiator: initiator,
                trickle: true, // Использование trickle ICE для более быстрого соединения
                stream: localStream
            });

            // Сохранение в карте
            peers.set(targetId, newPeer);

            // Настройка событий
            newPeer.on('signal', data => {
                // Отправка сигнальных данных (Offer, Answer, ICE) на сервер
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'WEBRTC_SIGNAL',
                        senderId: peerId,
                        targetId: targetId,
                        signal: data
                    }));
                }
            });

            newPeer.on('stream', stream => {
                // Прием удаленного потока
                addRemoteStream(targetId, targetNickname, stream);
            });

            newPeer.on('connect', () => {
                displayMessage({ 
                    type: 'SYSTEM', 
                    message: `P2P_CONNECTED_WITH: ${targetNickname}` 
                });
            });

            newPeer.on('close', () => {
                displayMessage({ 
                    type: 'SYSTEM', 
                    message: `P2P_CLOSED_WITH: ${targetNickname}` 
                });
                removePeer(targetId, true);
            });

            newPeer.on('error', (err) => {
                console.error(`P2P Error with ${targetId}:`, err);
                displayMessage({ 
                    type: 'ERROR', 
                    message: `P2P_ERROR_WITH: ${targetNickname} (${err.code})` 
                });
                removePeer(targetId, true);
            });
        }
        
        // [PEER_MANAGER] Обработка входящего сигнала
        function handleSignal(senderId, signal) {
            // Если сигнал пришел от нас самих (loopback), игнорируем
            if (senderId === peerId) return;

            // Если peer с отправителем уже существует, передаем сигнал
            if (peers.has(senderId)) {
                peers.get(senderId).signal(signal);
                return;
            }

            // Если peer не существует, но пришел 'offer' или 'signal' - создаем новый peer (не инициатор)
            if (signal.type === 'offer' || !signal.type) { // signal.type может быть undefined для ICE
                const senderInfo = allUsers.get(senderId);
                const senderNickname = senderInfo ? senderInfo.nickname : 'UNKNOWN';
                
                // Создаем peer
                if (localStream) {
                    createPeer(senderId, senderNickname, false);
                    peers.get(senderId).signal(signal);
                } else {
                     displayMessage({ type: 'WARNING', message: `Dropping incoming P2P signal from ${senderId}. Local media not ready.` });
                }
            }
        }

        // [PEER_MANAGER] Удаление P2P соединения и DOM-элемента
        function removePeer(targetId, destroy = false) {
            const remoteWrapper = document.getElementById(`video-${targetId}`);
            if (remoteWrapper) {
                remoteWrapper.remove();
            }
            if (peers.has(targetId)) {
                if (destroy) peers.get(targetId).destroy();
                peers.delete(targetId);
            }
        }
        
        // [DOM_MANIPULATION] Добавление удаленного стрима в DOM
        function addRemoteStream(id, nickname, stream) {
            let wrapper = document.getElementById(`video-${id}`);
            if (!wrapper) {
                wrapper = createVideoWrapper(id, nickname);
                videoGrid.appendChild(wrapper);
            }
            wrapper.querySelector('video').srcObject = stream;
        }
        
        // [DOM_MANIPULATION] Создание обертки для видео
        function createVideoWrapper(id, label) {
            const wrapper = document.createElement('div');
            wrapper.className = 'video-wrapper';
            wrapper.id = `video-${id}`;
            
            const video = document.createElement('video');
            video.autoplay = true;
            // video.muted = (id === peerId); // Только локальное видео должно быть muted
            
            const labelEl = document.createElement('div');
            labelEl.className = 'video-label';
            labelEl.textContent = `[CALLSIGN] ${label}`;
            
            wrapper.appendChild(video);
            wrapper.appendChild(labelEl);
            return wrapper;
        }

        // [CHAT] Отправка сообщения
        function sendMessage() {
            const message = messageInput.value.trim();
            if (!message || ws.readyState !== WebSocket.OPEN) return;

            const message_data = {
                type: 'CHAT_MESSAGE',
                sender: nickname,
                message: message
            };

            ws.send(JSON.stringify(message_data));
            messageInput.value = '';
        }

        function displayMessage(data) {
            const messageElement = document.createElement('p');
            
            if (data.type === 'SYSTEM' || data.type === 'ERROR' || data.type === 'WARNING') {
                messageElement.className = 'system-message';
                messageElement.innerHTML = `[${data.type}] ${data.message}`;
            } else {
                messageElement.className = 'user-message';
                messageElement.innerHTML = `<strong>[${data.sender}]</strong> > ${data.message}`;
            }
            
            chatBox.appendChild(messageElement);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        // [HANGUP] Завершение всех соединений
        function hangUp(do_disconnect = true) {
            // Уничтожение всех P2P соединений
            for (const peer of peers.values()) {
                peer.destroy();
            }
            peers.clear();
            
            // Остановка локального потока
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            // Очистка DOM
            videoGrid.innerHTML = ''; 
            
            // Если нужно закрыть WS
            if (do_disconnect && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            
            // Деактивация контролов
            hangupButton.disabled = true;
            audioToggle.disabled = true;
            videoToggle.disabled = true;
            audioToggle.textContent = '[MUTE_AUDIO]';
            videoToggle.textContent = '[DISABLE_VIDEO]';
            displayMessage({ type: 'SYSTEM', message: 'ALL_PROTOCOLS_TERMINATED.' });
        }
        
        // [CONTROLS] Переключение аудио
        function toggleAudio() {
            if (!localStream) return;
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                audioToggle.textContent = audioTrack.enabled ? '[MUTE_AUDIO]' : '[UNMUTE_AUDIO]';
                displayMessage({ type: 'SYSTEM', message: audioTrack.enabled ? 'AUDIO_UNMUTED_TO_ALL' : 'AUDIO_MUTED_TO_ALL' });
            }
        }

        // [CONTROLS] Переключение видео
        function toggleVideo() {
            if (!localStream) return;
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                videoToggle.textContent = videoTrack.enabled ? '[DISABLE_VIDEO]' : '[ENABLE_VIDEO]';
                displayMessage({ type: 'SYSTEM', message: videoTrack.enabled ? 'VIDEO_ENABLED_TO_ALL' : 'VIDEO_DISABLED_TO_ALL' });
            }
        }

        // АВТОЗАПУСК
        document.addEventListener('DOMContentLoaded', initWebSocket);
        
        // Автозапуск сохранения ника по Enter в поле ника
        nicknameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveNickname();
            }
        });
    </script>
</body>
</html>
